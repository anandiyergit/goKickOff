package main

// import "fmt"

// func value(i int) {
// 	i = 100
// 	fmt.Println("Inside value() i:", i)
// }

// func pointer(i *int) {
// 	*i = 100
// 	fmt.Println("Inside pointer(), address of i:", i)
// 	fmt.Println("Inside pointer(), value of i:", *i)
// }

// func main() {
// 	// i := 10
// 	// fmt.Println("The value of i:", i)
// 	// value(i)
// 	// fmt.Println("After calling value() i:", i)
// 	// pointer(&i)
// 	// fmt.Println("After calling pointer() i:", i)
// 	// // New way of calling pointers.
// 	// // This is different from other programming languages. If you observe the new keyword
// 	// // which is responsible to allocate memory based on the type and as Go takes care of garbage
// 	// // colection efficiently.
// 	// //
// 	// j := new(int)
// 	// fmt.Println("Address value of j:", *j)
// 	// pointer(j)
// 	// fmt.Println("After calling pointer(), value of j:", i)

// 	// One more interesting aspect
// 	var value float64 = 22.753
// 	pointer := &value
// 	pointer1 := &value
// 	fmt.Println("pointer value is:", *pointer)
// 	*pointer = *pointer / 2
// 	fmt.Println("pointer value is:", *pointer)
// 	fmt.Println("Value is:", value)
// 	fmt.Println("pointer1 is:", *pointer1)

//}
